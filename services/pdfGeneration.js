const PDFDocument = require("pdfkit");
const fs = require("fs");
const path = require("path");

class PDFGenerationService {
  constructor() {
    // Use /tmp directory for Vercel serverless environment
    if (process.env.VERCEL || process.env.NODE_ENV === "production") {
      this.outputDir = "/tmp/pdfs";
    } else {
      this.outputDir = path.join(__dirname, "../public/pdfs");
    }
    this.ensureOutputDir();
  }

  ensureOutputDir() {
    try {
      if (!fs.existsSync(this.outputDir)) {
        fs.mkdirSync(this.outputDir, { recursive: true });
      }
    } catch (error) {
      console.warn("Could not create PDF output directory:", error.message);
      // Fallback to /tmp if the original directory creation fails
      this.outputDir = "/tmp";
    }
  }

  async generateDocumentPDF(document, project) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: "A4",
          margins: {
            top: 50,
            bottom: 50,
            left: 50,
            right: 50,
          },
        });

        const filename = `${project.project_id}_${document.type}_v${
          document.version || 1
        }_${Date.now()}.pdf`;
        const filepath = path.join(this.outputDir, filename);

        const stream = fs.createWriteStream(filepath);
        doc.pipe(stream);

        // Header
        doc
          .fontSize(20)
          .font("Helvetica-Bold")
          .text(project.name, 50, 50)
          .fontSize(12)
          .font("Helvetica")
          .text(`Project ID: ${project.project_id}`, 50, 80)
          .text(`Document Type: ${document.type}`, 50, 100)
          .text(`Version: ${document.version || 1}`, 50, 120)
          .text(`Generated: ${new Date().toLocaleDateString()}`, 50, 140);

        // Add a line separator
        doc.moveTo(50, 170).lineTo(550, 170).stroke();

        // Content
        doc
          .fontSize(14)
          .font("Helvetica-Bold")
          .text("Document Content", 50, 190);

        doc
          .fontSize(10)
          .font("Helvetica")
          .text(this.formatContent(document.content), 50, 220, {
            width: 500,
            align: "left",
          });

        // Footer
        const pageHeight = doc.page.height;
        doc
          .fontSize(8)
          .text(
            `Generated by ReqGenAI - ${new Date().toISOString()}`,
            50,
            pageHeight - 30
          );

        doc.end();

        stream.on("finish", () => {
          resolve({
            success: true,
            filename,
            filepath,
            url: `/pdfs/${filename}`,
          });
        });

        stream.on("error", (error) => {
          reject(error);
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  formatContent(content) {
    if (typeof content === "string") {
      return content;
    }

    if (typeof content === "object") {
      return JSON.stringify(content, null, 2);
    }

    return String(content);
  }

  async generateProjectSummaryPDF(project, documents) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: "A4",
          margins: {
            top: 50,
            bottom: 50,
            left: 50,
            right: 50,
          },
        });

        const filename = `${
          project.project_id
        }_Project_Summary_${Date.now()}.pdf`;
        const filepath = path.join(this.outputDir, filename);

        const stream = fs.createWriteStream(filepath);
        doc.pipe(stream);

        // Header
        doc
          .fontSize(20)
          .font("Helvetica-Bold")
          .text(project.name, 50, 50)
          .fontSize(12)
          .font("Helvetica")
          .text(`Project ID: ${project.project_id}`, 50, 80)
          .text(`Status: ${project.status}`, 50, 100)
          .text(`Total Documents: ${project.totalDocuments}`, 50, 120)
          .text(`Generated: ${new Date().toLocaleDateString()}`, 50, 140);

        // Add a line separator
        doc.moveTo(50, 170).lineTo(550, 170).stroke();

        // Project Description
        doc
          .fontSize(14)
          .font("Helvetica-Bold")
          .text("Project Description", 50, 190);

        doc
          .fontSize(10)
          .font("Helvetica")
          .text(project.description || "No description available", 50, 220, {
            width: 500,
            align: "left",
          });

        // Documents Summary
        doc
          .fontSize(14)
          .font("Helvetica-Bold")
          .text("Documents Summary", 50, 280);

        let yPosition = 310;
        const documentTypes = [
          "REQUIREMENTS",
          "BRD",
          "BLUEPRINT",
          "RAW_INPUT",
          "DRAFT",
        ];

        documentTypes.forEach((type) => {
          const typeDocs = documents.filter((doc) => doc.type === type);
          if (typeDocs.length > 0) {
            doc
              .fontSize(12)
              .font("Helvetica-Bold")
              .text(
                `${type} (${typeDocs.length} version${
                  typeDocs.length !== 1 ? "s" : ""
                })`,
                50,
                yPosition
              );

            yPosition += 20;

            typeDocs.forEach((docItem, index) => {
              doc
                .fontSize(10)
                .font("Helvetica")
                .text(
                  `  • Version ${
                    docItem.version || 1
                  } - ${docItem.documentId.substring(0, 12)}... - ${new Date(
                    docItem.createdAt
                  ).toLocaleDateString()}`,
                  70,
                  yPosition
                );

              yPosition += 15;
            });

            yPosition += 10;
          }
        });

        // Footer
        const pageHeight = doc.page.height;
        doc
          .fontSize(8)
          .text(
            `Generated by ReqGenAI - ${new Date().toISOString()}`,
            50,
            pageHeight - 30
          );

        doc.end();

        stream.on("finish", () => {
          resolve({
            success: true,
            filename,
            filepath,
            url: `/pdfs/${filename}`,
          });
        });

        stream.on("error", (error) => {
          reject(error);
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  async generatePDFFromMarkdown(markdownContent, metadata) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          size: "A4",
          margins: {
            top: 50,
            bottom: 50,
            left: 50,
            right: 50,
          },
        });

        const filename = `${metadata.projectId}_${
          metadata.documentType
        }_v${Date.now()}.pdf`;
        const filepath = path.join(this.outputDir, filename);

        const stream = fs.createWriteStream(filepath);
        doc.pipe(stream);

        // Header
        doc
          .fontSize(20)
          .font("Helvetica-Bold")
          .text(metadata.projectName, 50, 50)
          .fontSize(12)
          .font("Helvetica")
          .text(`Project ID: ${metadata.projectId}`, 50, 80)
          .text(`Document Type: ${metadata.documentType}`, 50, 100)
          .text(`Generated: ${new Date().toLocaleDateString()}`, 50, 120);

        // Add a line separator
        doc.moveTo(50, 150).lineTo(550, 150).stroke();

        // Parse and format markdown content
        const formattedContent = this.parseMarkdownToPDF(markdownContent);

        // Add content
        doc.fontSize(10).font("Helvetica").text(formattedContent, 50, 170, {
          width: 500,
          align: "left",
        });

        // Footer
        const pageHeight = doc.page.height;
        doc
          .fontSize(8)
          .text(
            `Generated by ReqGenAI - ${new Date().toISOString()}`,
            50,
            pageHeight - 30
          );

        doc.end();

        stream.on("finish", () => {
          resolve({
            success: true,
            filename,
            filepath,
            url: `/pdfs/${filename}`,
          });
        });

        stream.on("error", (error) => {
          reject(error);
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  async generatePDFFromHTML(htmlContent, metadata) {
    return new Promise((resolve, reject) => {
      try {
        const puppeteer = require("puppeteer");

        (async () => {
          try {
            // Launch browser
            const browser = await puppeteer.launch({
              headless: true,
              args: ["--no-sandbox", "--disable-setuid-sandbox"],
            });

            const page = await browser.newPage();

            // Set content and wait for it to load
            await page.setContent(htmlContent, { waitUntil: "networkidle0" });

            // Generate filename
            const filename = `${metadata.projectId}_${
              metadata.documentType
            }_v${Date.now()}.pdf`;
            const filepath = path.join(this.outputDir, filename);

            // Generate PDF
            await page.pdf({
              path: filepath,
              format: "A4",
              printBackground: true,
              margin: {
                top: "20mm",
                right: "20mm",
                bottom: "20mm",
                left: "20mm",
              },
            });

            await browser.close();

            resolve({
              success: true,
              filename,
              filepath,
              url: `/pdfs/${filename}`,
            });
          } catch (error) {
            reject(error);
          }
        })();
      } catch (error) {
        reject(error);
      }
    });
  }

  parseMarkdownToPDF(markdownContent) {
    // Simple markdown parsing for PDF generation
    let content = markdownContent;

    // Remove markdown headers and convert to plain text
    content = content.replace(/^#+\s*/gm, ""); // Remove # headers
    content = content.replace(/\*\*(.*?)\*\*/g, "$1"); // Remove **bold**
    content = content.replace(/\*(.*?)\*/g, "$1"); // Remove *italic*
    content = content.replace(/`(.*?)`/g, "$1"); // Remove `code`
    content = content.replace(/\[([^\]]+)\]\([^)]+\)/g, "$1"); // Remove [links](url)
    content = content.replace(/^\s*[-*+]\s*/gm, "• "); // Convert list items
    content = content.replace(/^\s*\d+\.\s*/gm, ""); // Remove numbered lists

    return content;
  }
}

// Lazy-load the service to avoid directory creation issues during module load
let pdfService = null;

const getPDFService = () => {
  if (!pdfService) {
    pdfService = new PDFGenerationService();
  }
  return pdfService;
};

module.exports = {
  generateDocumentPDF: (...args) => getPDFService().generateDocumentPDF(...args),
  generatePDFFromHTML: (...args) => getPDFService().generatePDFFromHTML(...args),
  generatePDFFromMarkdown: (...args) => getPDFService().generatePDFFromMarkdown(...args),
  parseMarkdownToPDF: (...args) => getPDFService().parseMarkdownToPDF(...args),
};
